(* SPDX-License-Identifier: MIT *)
scilla_version 0

(***************************************************)
(*               Associated library                *)
(***************************************************)
import IntUtils ListUtils 

library MintingPool
let one = Uint256 1
let zero = Uint128 0
let true = True
let false = False
let empty_string = ""
let one_msg = 
    fun (msg : Message) => 
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg   

(* Dummy user-defined ADT *)
type Error =
| CodeIsOracle
| CodeIsPendingRequest
| CodeIsOracleAddressNotSet
| CodeIsOwner
| CodeIsNFTContractAddressNotSet
| CodeIsCallerAddressNotSet
| CodeIsBatchPendingRequest

(* let cons_one_batch = 
    fun (to: ByStr20) =>
    fun (seed: Uint256) =>
        BatchParam to empty_string seed

let cons_all_batch =
    fun (seeds: List (Uint256)) =>
    fun (to: ByStr20) =>
        let f = cons_one_batch to in
        let batch_list_uint256 = @list_map Uint256 BatchParam in
        batch_list_uint256 f seeds *)

let make_error =
    fun (result : Error) =>
        let result_code = 
        match result with
        | CodeIsOracle               => Int32 -1
        | CodeIsPendingRequest       => Int32 -2
        | CodeIsOracleAddressNotSet  => Int32 -3
        | CodeIsOwner                => Int32 -4
        | CodeIsNFTContractAddressNotSet => Int32 -5
        | CodeIsCallerAddressNotSet => Int32 -6
        | CodeIsBatchPendingRequest => Int32 -7
        end
        in
        { _exception : "Error"; code : result_code }


(***************************************************)
(*             The contract definition             *)
(***************************************************)
contract MintingPool 
(
    contract_owner: ByStr20
)

(* Mutable fields *)
field oracleAddress: Option ByStr20 = None {ByStr20}
field heroesNFTAddress: Option ByStr20 = None {ByStr20}

(* 1-3 Heroes Summon requests*)
field myH13Requests: Map Uint256 Bool = Emp Uint256 Bool
field myH13BatchRequests: Map Uint256 Bool = Emp Uint256 Bool
field requestedH13CallerCount: Uint256 = Uint256 0
field processedH13CallerCount: Uint256 = Uint256 0
field requestedH13BatchCallerCount: Uint256 = Uint256 0
field processedH13BatchCallerCount: Uint256 = Uint256 0
(* Mapping for caller Address id to caller address *)
field callerH13Addresses: Map Uint256 ByStr20 = Emp Uint256 ByStr20
(* Mapping for caller Address id to caller address *)
field batchCallerH13Addresses: Map Uint256 ByStr20 = Emp Uint256 ByStr20



(* 3-5 Heroes Summon requests*)
field my35Requests: Map Uint256 Bool = Emp Uint256 Bool
field my35BatchRequests: Map Uint256 Bool = Emp Uint256 Bool




(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(error: Error)
    e = make_error error;
    throw e
end




procedure IsNotOracle(address: ByStr20)
    oracleAddressTmp <- oracleAddress;
    match oracleAddressTmp with
    | Some v =>
        is_oracle = builtin eq v address;
        match is_oracle with
        | False =>
            err = CodeIsOracle;
            ThrowError err
        | True =>
        end
    | None =>
        err = CodeIsOracleAddressNotSet;
        ThrowError err
    end
end


procedure IsNotPendingRequest(id: Uint256)
    isPendingRequest <- exists myH13Requests[id];
    match isPendingRequest with
    | False =>
        err = CodeIsPendingRequest;
        ThrowError err
    | True =>
    end
end

procedure IsNotBatchPendingRequest(id: Uint256)
    isBatchPendingRequest <- exists myH13BatchRequests[id];
    match isBatchPendingRequest with
    | False =>
        err = CodeIsBatchPendingRequest;
        ThrowError err
    | True =>
    end
end

procedure IsNotOwner(address: ByStr20)
    is_owner = builtin eq contract_owner address;
    match is_owner with
    | False =>
        err = CodeIsOwner;
        ThrowError err
    | True =>
    end
end

(***************************************)
(*             Transitions             *)
(***************************************)

(* @dev: Set Oracle Contract address. Only contract owner allowed to invoke.   *)
(* param oracleAddress:      Address of the oracle contract.                  *)
transition setOracleAddress(oracleAddr : ByStr20)
    IsNotOwner _sender;
    oracleAddressTmp = Some {ByStr20} oracleAddr ;
    oracleAddress := oracleAddressTmp
end

(* @dev: Set Heroes NFT Contract address. Only contract owner allowed to invoke.   *)
(* param oracleAddress:      Address of the oracle contract.                  *)
transition setHeroesNFTAddress(heroesNFTAddress : ByStr20)
    IsNotOwner _sender;
    heroesNFTAddressTmp = Some {ByStr20} heroesNFTAddress ;
    heroesNFTAddress := heroesNFTAddressTmp
end

(* @dev: Transition for users to Mint 1*-3* Heroes.This transition invokes requestRandomNumber() transition in the oracle contract   *)
transition Mint13Heroes()
    oracleAddressTmp <- oracleAddress;
    heroesNFTAddressTmp <- heroesNFTAddress;
    match oracleAddressTmp with
    | Some v =>
        match heroesNFTAddressTmp with
        | Some heroesValue =>
            msg = {_tag: "requestH13RandomNumber"; _recipient: v; _amount: zero};
            msgs = one_msg msg;
            send msgs;
            requestedH13CallerCountTmp <- requestedH13CallerCount;
            callerH13Addresses[requestedH13CallerCountTmp] := _sender;
            tmpVal = builtin add requestedH13CallerCountTmp one;
            requestedH13CallerCount := tmpVal
        | None =>
            err = CodeIsNFTContractAddressNotSet;
            ThrowError err
        end
    | None =>
        err = CodeIsOracleAddressNotSet;
        ThrowError err
    end
end
(* @dev: Transition for users to Batch Mint 1*-3* Heroes.This transition invokes requestBatchRandomNumber() transition in the oracle contract   *)
transition BatchMint13Heroes()
    oracleAddressTmp <- oracleAddress;
    heroesNFTAddressTmp <- heroesNFTAddress;
    match oracleAddressTmp with
    | Some v =>
        match heroesNFTAddressTmp with
        | Some heroesValue =>
            msg = {_tag: "requestH13BatchRandomNumber"; _recipient: v; _amount: zero};
            msgs = one_msg msg;
            send msgs;
            requestedH13BatchCallerCountTmp <- requestedH13BatchCallerCount;
            batchCallerH13Addresses[requestedH13BatchCallerCountTmp] := _sender;
            tmpVal = builtin add requestedH13BatchCallerCountTmp one;
            requestedH13BatchCallerCount := tmpVal
        | None =>
            err = CodeIsNFTContractAddressNotSet;
            ThrowError err
        end
    | None =>
        err = CodeIsOracleAddressNotSet;
        ThrowError err
    end
end
(* @dev: Receive request id from the oracle contract. Only oracle contract allowed to invoke.   *)
(* param id:      Request id.                                                                   *)
transition getH13RequestId(id: Uint256)
    IsNotOracle _sender;
    myH13Requests[id] := true;
    e = {_eventname: "ReceivedNewH13RequestId"; id: id};
    event e
end

transition getH13BatchRequestId(id: Uint256)
    IsNotOracle _sender;
    myH13BatchRequests[id] := true;
    e = {_eventname: "ReceivedNewBatchH13RequestId"; id: id};
    event e
end

(* @dev: Receive Random Number and request id from oracle contract and then invokes Mint() transition of the Heroes NFT contract. Only oracle contract allowed to invoke  *)
(* param randomnumber:      Random Number.                                                                     *)
(* param id:       Request id.                                                                             *)
transition callbackH13(random_number: Uint256, id: Uint256)
    IsNotOracle _sender;
    IsNotPendingRequest id;
    e = {_eventname: "RandomNumberH13Received"; random_number: random_number};
    event e;
    delete myH13Requests[id];
    processedH13CallerCountTmp <- processedH13CallerCount;
    callerAddress <- callerH13Addresses[processedH13CallerCountTmp];
    delete callerH13Addresses[processedH13CallerCountTmp];
    tmpVal = builtin add processedH13CallerCountTmp one;
    processedH13CallerCount := tmpVal;
    (* Call NFT contract's Mint function with the received random number *)
    (* This contract address must be set as Minter in the NFT Contract *)
    heroesNFTAddressTmp <- heroesNFTAddress;
    match heroesNFTAddressTmp with
    | Some v =>
        match callerAddress with
        | Some value =>
            msg = {_tag: "Mint"; _recipient: v; _amount: zero; to: value; token_uri: ""; seed: random_number; is_high_level: false};
            msgs = one_msg msg;
            send msgs
        | None =>
            err = CodeIsCallerAddressNotSet;
            ThrowError err
        end
    | None =>
        err = CodeIsOracleAddressNotSet;
        ThrowError err
    end
end

transition callbackBatchH13(random_numbers: List (Uint256), id: Uint256)
    IsNotOracle _sender;
    IsNotBatchPendingRequest id;
    e = {_eventname: "RandomNumberH13BatchReceived"; random_numbers: random_numbers};
    event e;
    delete myH13BatchRequests[id];
    processedH13BatchCallerCountTmp <- processedH13BatchCallerCount;
    batchCallerAddress <- batchCallerH13Addresses[processedH13BatchCallerCountTmp];
    delete batchCallerH13Addresses[processedH13BatchCallerCountTmp];
    tmpVal = builtin add processedH13BatchCallerCountTmp one;
    processedH13BatchCallerCount := tmpVal;

    (* Call NFT contract's Mint function with the received random number *)
    (* This contract address must be set as Minter in the NFT Contract *)
    
    heroesNFTAddressTmp <- heroesNFTAddress;
    match heroesNFTAddressTmp with
    | Some v =>
        match batchCallerAddress with
        | Some value =>
            (* batchParams = cons_all_batch random_numbers value; *)
            msg = {_tag: "BatchMint"; _recipient: v; _amount: zero; to: value; seeds: random_numbers; is_high_level: false};
            msgs = one_msg msg;
            send msgs               
        | None =>
            err = CodeIsCallerAddressNotSet;
            ThrowError err
        end
        
    | None =>
        err = CodeIsOracleAddressNotSet;
        ThrowError err
    end
end


transition Heroes_MintCallback(to: ByStr20, token_id: Uint256, token_uri: String)
    e = {_eventname: "HeroNFTIsMinted"; to: to; token_id: token_id; token_uri: token_uri};
    event e
end

transition Heroes_BatchMintCallback()
    e = {_eventname: "HeroesNFTBatchMintSuccessful"};
    event e
end